# kit-example
example for how to ship source code as optional kit in a nodejs project

## Requirement

### Development
- Dependency should be managed by each app/lib/plugin(kit)
- package-lock update shouldn't be a critical path for development which blocks productivity

### Shipment
- Ship as source code
- Dependencies are required for offline installation
- Plugins/kits are optional to deploy

### Deployment 
- Install environment deployment should be only for selected plugins/kits
- Build should work as expected

## Proposal

### Development
- In monorepo, dependencies could be defined in the package.json(s) of each app/lib/plugin(kit)
- package-lock update could be done by ci and either update the branch or upload to different storage with hash.

### Shipment
- Each plugin(kit) will be zipped/packed separately.
- Dependencies can be identified by install dependencies selectively:
```bash
# install base dependencies
npm ci -w apps/* libs/*

copy_base_node_modules_and_apps_and_libs_and_zip_it

# install plugin dependencies only then we know which deps are only required for this plugin
npm ci -w plugins/buyer

move_delta_node_modules_and_copy_plugin_buyer_and_zip_it

# install plugin dependencies only then we know which deps are only required for this plugin
npm ci -w plugins/seller

move_delta_node_modules_and_copy_plugin_seller_and_zip_it
```
- If on plugin depends on the other plugin by definition, same approach can be applied to identify the dependencies for different level.
- It is a stable solution since everything happens under node_modules folder and package-lock.json.
- If we have symlink for some external base lib, and we want to test it with shipment, it can be run has hard copy without `npm pack`.

### Installation 
- Based on the plugin selection, the corresponding zip(s) will be unzipped to a trimmed monorepo folder.
- Then all the script can be run as same as the development environment.

## Migration Consideration
If an existing project is not in monorepo practice and putting all deps in root package.json directly, we could migrate it to approach above by:
- Convert the plugin(kit) that has deps to use package.json and move corresponding deps to it.
- Convert the root package.json to monorepo by adding that `workspaces` field. Nothing should be broken.
- Refactor shipment script to have that node_modules copy and zip logic.
 
## Notes
- In monorepo, if a sub package has bundledDependencies, the dependency will be skip to install if the package-lock.json is generated by `npm i --install-strategy=nested`
